<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.1" />
<title>app.board API documentation</title>
<meta name="description" content="Represents the board" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>app.board</code></h1>
</header>
<section id="section-intro">
<p>Represents the board</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
    Represents the board
&#39;&#39;&#39;
from PyQt5.QtWidgets import QFrame
from PyQt5.QtCore import Qt, QBasicTimer, pyqtSignal, QPoint
from PyQt5.QtGui import QPainter, QColor, QPen
from .piece import Piece
from .game_logic import (GameLogic, GameOverPassError, KOError, SuicideError,
                         OccupiedError)


class Board(QFrame):  # base the board on a QFrame widget

    # Signal for the player timer being updated by timerEvent
    updatePlayersTimer = pyqtSignal(object)
    # Signal for updating the score
    updateScoreSignal = pyqtSignal(object)
    # Signal for if there is a logic error (KO/Suicide/Occupied)
    updateLogicSignal = pyqtSignal(str)
    # Signal for for the current player
    updateCurrentPlayerSignal = pyqtSignal(object)
    # Signal for game over
    updateGameOverSignal = pyqtSignal()

    boardWidth = 7
    boardHeight = 7
    # Timer speed is denoted in milliseconds
    timerSpeed = 1000

    # Colours to denote checks each representing an RGB tuple
    checkColours = [(255, 235, 205), (205, 133, 63)]

    def __init__(self, parent):
        super().__init__(parent)
        self.initBoard()

    def initBoard(self):
        &#39;&#39;&#39;
            Initiates the board
        &#39;&#39;&#39;
        # Timer for tracking time
        self.timer = QBasicTimer()
        # Denotes if the game is underway
        self.isStarted = False
        # The initial board
        self.boardArray = [[Piece.NoPiece for j in range(self.boardWidth)]
                           for i in range(self.boardHeight)]
        # The gameLogic that controls play
        self.gameLogic = GameLogic(self.boardArray)
        # Start the game
        self.start()

    def getCurrentPlayer(self):
        &#39;&#39;&#39;
            Helper method to fetch the current player from the logic instance

            Returns:
                Player
        &#39;&#39;&#39;
        return self.gameLogic.getPlayers()[self.gameLogic.player]

    def printBoardArray(self, board):
        &#39;&#39;&#39;
            Pretty prints the boardArray to the terminal

            Args:
                board (list): A board
        &#39;&#39;&#39;
        print(&#34;boardArray:&#34;)
        print(&#39;\n&#39;.join(
            [&#39;\t&#39;.join([str(cell) for cell in row]) for row in board]))

    def squareWidth(self):
        &#39;&#39;&#39;
            Returns the width of one square in the board

            Returns:
                float
        &#39;&#39;&#39;
        return self.contentsRect().width() / self.boardWidth

    def squareHeight(self):
        &#39;&#39;&#39;
            Returns the height of one square of the board

            Returns:
                float
        &#39;&#39;&#39;
        return self.contentsRect().height() / self.boardHeight

    def start(self):
        &#39;&#39;&#39;
            Start the game
        &#39;&#39;&#39;
        self.isStarted = True  # determines if the game has started to TRUE
        self.resetGame()  # reset the game
        self.timer.start(self.timerSpeed, self)

    def timerEvent(self, event):
        &#39;&#39;&#39;
            This event is automatically called when the timer is updated.
            Based on the timerSpeed variable.

            Args:
                event (Event): Timer event
        &#39;&#39;&#39;
        # if the timer that has &#39;ticked&#39; is the one in this class
        if event.timerId() == self.timer.timerId():
            # Get the current player
            player = self.getCurrentPlayer()
            # If there is no time remaining, then game over
            if player.timeRemaining &lt;= 0:
                self.updateGameOverSignal.emit()
            else:
                player.timeRemaining -= 1
            # Emit the new state of the timer
            self.updatePlayersTimer.emit(self.gameLogic.getPlayers())
        else:
            # if we do not handle an event pass it to the parent class
            super(Board, self).timerEvent(event)

    def paintEvent(self, event=None):
        &#39;&#39;&#39;
            Paints the board and the pieces of the game

            Args:
                event (Event): The paint event
        &#39;&#39;&#39;
        painter = QPainter(self)
        self.drawBoardSquares(painter)
        self.drawPieces(painter)

    def mousePressEvent(self, event):
        &#39;&#39;&#39;
            Mouse press event handler

            Args:
                event (Event): The mouse press event
        &#39;&#39;&#39;
        # Get the current row/col where this click occured
        row, col = self.getSquareRowCol(event.x(), event.y())
        # On mouse press try and update the board logic
        try:
            self.gameLogic.updateBoard(row, col)
            self.updateLogicSignal.emit(&#34;&#34;)
        # Handle all of the different logical errors that can occur
        except KOError:
            self.updateLogicSignal.emit(f&#34;KO\ntry again&#34;)
        except SuicideError:
            self.updateLogicSignal.emit(f&#34;Suicide\ntry again&#34;)
        except OccupiedError:
            self.updateLogicSignal.emit(f&#34;Occupied\ntry again&#34;)
        # Whatever happens, update the board
        finally:
            self.boardArray = self.gameLogic.board
        # Emit the current player (this switches in the updateBoard logic)
        self.updateCurrentPlayerSignal.emit(self.getCurrentPlayer())
        # Emit the latest player objects
        self.updateScoreSignal.emit(self.gameLogic.getPlayers())
        # Redraw the GUI
        self.update()

    def resetGame(self):
        &#39;&#39;&#39;
            Clears pieces from the board&#39;
        &#39;&#39;&#39;
        # Reset the logic
        self.gameLogic.reset()
        # Reset the board
        self.boardArray = self.gameLogic.board
        # Emit the player objects with reset scores
        self.updateScoreSignal.emit(self.gameLogic.getPlayers())
        # Emit the current player
        self.updateCurrentPlayerSignal.emit(self.getCurrentPlayer())
        # Redraw the GUI
        self.update()

    def undo(self):
        &#39;&#39;&#39;
            Undo last turn
        &#39;&#39;&#39;
        print(&#34;Not implemented&#34;)

    def skip(self):
        &#39;&#39;&#39;
            Handle skip / passes
        &#39;&#39;&#39;
        # Try and skip a go, unless there are two skips - then emit game over
        try:
            self.gameLogic.skip()
            self.updateCurrentPlayerSignal.emit(self.getCurrentPlayer())
        except GameOverPassError:
            self.updateGameOverSignal.emit()

    def drawBoardSquares(self, painter):
        &#39;&#39;&#39;
            Draw all the square on the board

            Args:
                painter (QPainter): The painter to paint on the widget with
        &#39;&#39;&#39;
        for row in range(0, Board.boardHeight):
            for col in range(0, Board.boardWidth):
                self.drawSquare(
                    painter, col, row, self.checkColours[0] if
                    (col + row) % 2 == 1 else self.checkColours[1])

    def drawPieces(self, painter):
        &#39;&#39;&#39;
            Draw the prices on the board

            Args:
                painter (QPainter): The painter to paint with

                black and white squares being drawn on board
        &#39;&#39;&#39;
        for row in range(0, len(self.boardArray)):
            for col in range(0, len(self.boardArray[0])):
                square = self.boardArray[row][col]
                if square == 0:
                    self.drawEmptySpace(painter, col, row)
                elif square == 1:
                    self.drawWhitePiece(painter, col, row)
                else:
                    self.drawBlackPiece(painter, col, row)

    def drawEmptySpace(self, painter, col, row):
        &#39;&#39;&#39;
            Helper method to draw an empty space at the given col, row

            Args:
                painter (QPainter): The painter
                col     (int):      The column to draw at
                row     (int):      The row to draw at
        &#39;&#39;&#39;
        self.drawPiece(painter, col, row, Qt.transparent)

    def drawBlackPiece(self, painter, col, row):
        &#39;&#39;&#39;
            Helper method to draw a black piece at the given col, row

            Args:
                painter (QPainter): The painter
                col     (int):      The column to draw at
                row     (int):      The row to draw at
        &#39;&#39;&#39;
        self.drawPiece(painter, col, row, Qt.black)

    def drawWhitePiece(self, painter, col, row):
        &#39;&#39;&#39;
            Helper method to draw a white piece at the given col, row

            Args:
                painter (QPainter): The painter
                col     (int):      The column to draw at
                row     (int):      The row to draw at
        &#39;&#39;&#39;
        self.drawPiece(painter, col, row, Qt.white)

    def drawPiece(self, painter, col, row, color):
        &#39;&#39;&#39;
            Draw a piece at the given col, row
            pen is doing the circle
            brush is filling in the circle

            Args:
                painter (QPainter): The painter
                col     (int):      The column to draw at
                row     (int):      The row to draw at
                color   (Qt.color): The color for the piece
        &#39;&#39;&#39;
        painter.save()
        painter.setPen(QPen(QColor(color), 0))
        painter.setBrush(QColor(color))
        painter.translate(*self.getSquareCoords(col, row))
        radius = (self.squareWidth() - 2) / 5
        center = QPoint(self.squareWidth() // 2, self.squareHeight() // 2)
        painter.drawEllipse(center, radius, radius)
        painter.restore()

    def drawSquare(self, painter, col, row, color):
        &#39;&#39;&#39;
            Draw a board square on the board

            Args:
                painter (QPainter): The QPainter instance we are using
                col     (int)     : The current column we are rendering in
                row     (row)     : The current row we are rendering in
                rgb     (iter)    : The rgba int values
        &#39;&#39;&#39;
        width = int(self.squareWidth())
        height = int(self.squareHeight())
        midWidth = width // 2
        midHeight = height // 2
        painter.save()
        painter.translate(*self.getSquareCoords(col, row))
        painter.fillRect(0, 0, width, height, QColor(*color))
        painter.setPen(QPen(QColor(139, 69, 19), 2))
        painter.drawRect(0, 0, width, height)
        painter.drawLine(0, midHeight, width, midHeight)
        painter.drawLine(midWidth, 0, midWidth, height)
        painter.restore()

    def getSquareCoords(self, col, row):
        &#39;&#39;&#39;
            Calculate the square coords

            Args:
                col (int): The currrent col
                row (int): The current row

            Returns:
                Tuple
        &#39;&#39;&#39;
        return (self.squareWidth() * col, self.squareHeight() * row)

    def getSquareRowCol(self, x, y):
        &#39;&#39;&#39;
            Given X and Y find the column and the row

            Args:
                x (int):    The X POS
                y (int):    The Y POS

            Returns:
                Tuple
        &#39;&#39;&#39;
        return (int(y // self.squareHeight()), int(x // self.squareWidth()))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="app.board.Board"><code class="flex name class">
<span>class <span class="ident">Board</span></span>
<span>(</span><span>parent)</span>
</code></dt>
<dd>
<section class="desc"><p>QFrame(parent: QWidget = None, flags: Union[Qt.WindowFlags, Qt.WindowType] = Qt.WindowFlags())</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Board(QFrame):  # base the board on a QFrame widget

    # Signal for the player timer being updated by timerEvent
    updatePlayersTimer = pyqtSignal(object)
    # Signal for updating the score
    updateScoreSignal = pyqtSignal(object)
    # Signal for if there is a logic error (KO/Suicide/Occupied)
    updateLogicSignal = pyqtSignal(str)
    # Signal for for the current player
    updateCurrentPlayerSignal = pyqtSignal(object)
    # Signal for game over
    updateGameOverSignal = pyqtSignal()

    boardWidth = 7
    boardHeight = 7
    # Timer speed is denoted in milliseconds
    timerSpeed = 1000

    # Colours to denote checks each representing an RGB tuple
    checkColours = [(255, 235, 205), (205, 133, 63)]

    def __init__(self, parent):
        super().__init__(parent)
        self.initBoard()

    def initBoard(self):
        &#39;&#39;&#39;
            Initiates the board
        &#39;&#39;&#39;
        # Timer for tracking time
        self.timer = QBasicTimer()
        # Denotes if the game is underway
        self.isStarted = False
        # The initial board
        self.boardArray = [[Piece.NoPiece for j in range(self.boardWidth)]
                           for i in range(self.boardHeight)]
        # The gameLogic that controls play
        self.gameLogic = GameLogic(self.boardArray)
        # Start the game
        self.start()

    def getCurrentPlayer(self):
        &#39;&#39;&#39;
            Helper method to fetch the current player from the logic instance

            Returns:
                Player
        &#39;&#39;&#39;
        return self.gameLogic.getPlayers()[self.gameLogic.player]

    def printBoardArray(self, board):
        &#39;&#39;&#39;
            Pretty prints the boardArray to the terminal

            Args:
                board (list): A board
        &#39;&#39;&#39;
        print(&#34;boardArray:&#34;)
        print(&#39;\n&#39;.join(
            [&#39;\t&#39;.join([str(cell) for cell in row]) for row in board]))

    def squareWidth(self):
        &#39;&#39;&#39;
            Returns the width of one square in the board

            Returns:
                float
        &#39;&#39;&#39;
        return self.contentsRect().width() / self.boardWidth

    def squareHeight(self):
        &#39;&#39;&#39;
            Returns the height of one square of the board

            Returns:
                float
        &#39;&#39;&#39;
        return self.contentsRect().height() / self.boardHeight

    def start(self):
        &#39;&#39;&#39;
            Start the game
        &#39;&#39;&#39;
        self.isStarted = True  # determines if the game has started to TRUE
        self.resetGame()  # reset the game
        self.timer.start(self.timerSpeed, self)

    def timerEvent(self, event):
        &#39;&#39;&#39;
            This event is automatically called when the timer is updated.
            Based on the timerSpeed variable.

            Args:
                event (Event): Timer event
        &#39;&#39;&#39;
        # if the timer that has &#39;ticked&#39; is the one in this class
        if event.timerId() == self.timer.timerId():
            # Get the current player
            player = self.getCurrentPlayer()
            # If there is no time remaining, then game over
            if player.timeRemaining &lt;= 0:
                self.updateGameOverSignal.emit()
            else:
                player.timeRemaining -= 1
            # Emit the new state of the timer
            self.updatePlayersTimer.emit(self.gameLogic.getPlayers())
        else:
            # if we do not handle an event pass it to the parent class
            super(Board, self).timerEvent(event)

    def paintEvent(self, event=None):
        &#39;&#39;&#39;
            Paints the board and the pieces of the game

            Args:
                event (Event): The paint event
        &#39;&#39;&#39;
        painter = QPainter(self)
        self.drawBoardSquares(painter)
        self.drawPieces(painter)

    def mousePressEvent(self, event):
        &#39;&#39;&#39;
            Mouse press event handler

            Args:
                event (Event): The mouse press event
        &#39;&#39;&#39;
        # Get the current row/col where this click occured
        row, col = self.getSquareRowCol(event.x(), event.y())
        # On mouse press try and update the board logic
        try:
            self.gameLogic.updateBoard(row, col)
            self.updateLogicSignal.emit(&#34;&#34;)
        # Handle all of the different logical errors that can occur
        except KOError:
            self.updateLogicSignal.emit(f&#34;KO\ntry again&#34;)
        except SuicideError:
            self.updateLogicSignal.emit(f&#34;Suicide\ntry again&#34;)
        except OccupiedError:
            self.updateLogicSignal.emit(f&#34;Occupied\ntry again&#34;)
        # Whatever happens, update the board
        finally:
            self.boardArray = self.gameLogic.board
        # Emit the current player (this switches in the updateBoard logic)
        self.updateCurrentPlayerSignal.emit(self.getCurrentPlayer())
        # Emit the latest player objects
        self.updateScoreSignal.emit(self.gameLogic.getPlayers())
        # Redraw the GUI
        self.update()

    def resetGame(self):
        &#39;&#39;&#39;
            Clears pieces from the board&#39;
        &#39;&#39;&#39;
        # Reset the logic
        self.gameLogic.reset()
        # Reset the board
        self.boardArray = self.gameLogic.board
        # Emit the player objects with reset scores
        self.updateScoreSignal.emit(self.gameLogic.getPlayers())
        # Emit the current player
        self.updateCurrentPlayerSignal.emit(self.getCurrentPlayer())
        # Redraw the GUI
        self.update()

    def undo(self):
        &#39;&#39;&#39;
            Undo last turn
        &#39;&#39;&#39;
        print(&#34;Not implemented&#34;)

    def skip(self):
        &#39;&#39;&#39;
            Handle skip / passes
        &#39;&#39;&#39;
        # Try and skip a go, unless there are two skips - then emit game over
        try:
            self.gameLogic.skip()
            self.updateCurrentPlayerSignal.emit(self.getCurrentPlayer())
        except GameOverPassError:
            self.updateGameOverSignal.emit()

    def drawBoardSquares(self, painter):
        &#39;&#39;&#39;
            Draw all the square on the board

            Args:
                painter (QPainter): The painter to paint on the widget with
        &#39;&#39;&#39;
        for row in range(0, Board.boardHeight):
            for col in range(0, Board.boardWidth):
                self.drawSquare(
                    painter, col, row, self.checkColours[0] if
                    (col + row) % 2 == 1 else self.checkColours[1])

    def drawPieces(self, painter):
        &#39;&#39;&#39;
            Draw the prices on the board

            Args:
                painter (QPainter): The painter to paint with

                black and white squares being drawn on board
        &#39;&#39;&#39;
        for row in range(0, len(self.boardArray)):
            for col in range(0, len(self.boardArray[0])):
                square = self.boardArray[row][col]
                if square == 0:
                    self.drawEmptySpace(painter, col, row)
                elif square == 1:
                    self.drawWhitePiece(painter, col, row)
                else:
                    self.drawBlackPiece(painter, col, row)

    def drawEmptySpace(self, painter, col, row):
        &#39;&#39;&#39;
            Helper method to draw an empty space at the given col, row

            Args:
                painter (QPainter): The painter
                col     (int):      The column to draw at
                row     (int):      The row to draw at
        &#39;&#39;&#39;
        self.drawPiece(painter, col, row, Qt.transparent)

    def drawBlackPiece(self, painter, col, row):
        &#39;&#39;&#39;
            Helper method to draw a black piece at the given col, row

            Args:
                painter (QPainter): The painter
                col     (int):      The column to draw at
                row     (int):      The row to draw at
        &#39;&#39;&#39;
        self.drawPiece(painter, col, row, Qt.black)

    def drawWhitePiece(self, painter, col, row):
        &#39;&#39;&#39;
            Helper method to draw a white piece at the given col, row

            Args:
                painter (QPainter): The painter
                col     (int):      The column to draw at
                row     (int):      The row to draw at
        &#39;&#39;&#39;
        self.drawPiece(painter, col, row, Qt.white)

    def drawPiece(self, painter, col, row, color):
        &#39;&#39;&#39;
            Draw a piece at the given col, row
            pen is doing the circle
            brush is filling in the circle

            Args:
                painter (QPainter): The painter
                col     (int):      The column to draw at
                row     (int):      The row to draw at
                color   (Qt.color): The color for the piece
        &#39;&#39;&#39;
        painter.save()
        painter.setPen(QPen(QColor(color), 0))
        painter.setBrush(QColor(color))
        painter.translate(*self.getSquareCoords(col, row))
        radius = (self.squareWidth() - 2) / 5
        center = QPoint(self.squareWidth() // 2, self.squareHeight() // 2)
        painter.drawEllipse(center, radius, radius)
        painter.restore()

    def drawSquare(self, painter, col, row, color):
        &#39;&#39;&#39;
            Draw a board square on the board

            Args:
                painter (QPainter): The QPainter instance we are using
                col     (int)     : The current column we are rendering in
                row     (row)     : The current row we are rendering in
                rgb     (iter)    : The rgba int values
        &#39;&#39;&#39;
        width = int(self.squareWidth())
        height = int(self.squareHeight())
        midWidth = width // 2
        midHeight = height // 2
        painter.save()
        painter.translate(*self.getSquareCoords(col, row))
        painter.fillRect(0, 0, width, height, QColor(*color))
        painter.setPen(QPen(QColor(139, 69, 19), 2))
        painter.drawRect(0, 0, width, height)
        painter.drawLine(0, midHeight, width, midHeight)
        painter.drawLine(midWidth, 0, midWidth, height)
        painter.restore()

    def getSquareCoords(self, col, row):
        &#39;&#39;&#39;
            Calculate the square coords

            Args:
                col (int): The currrent col
                row (int): The current row

            Returns:
                Tuple
        &#39;&#39;&#39;
        return (self.squareWidth() * col, self.squareHeight() * row)

    def getSquareRowCol(self, x, y):
        &#39;&#39;&#39;
            Given X and Y find the column and the row

            Args:
                x (int):    The X POS
                y (int):    The Y POS

            Returns:
                Tuple
        &#39;&#39;&#39;
        return (int(y // self.squareHeight()), int(x // self.squareWidth()))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QFrame</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="app.board.Board.boardHeight"><code class="name">var <span class="ident">boardHeight</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="app.board.Board.boardWidth"><code class="name">var <span class="ident">boardWidth</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="app.board.Board.checkColours"><code class="name">var <span class="ident">checkColours</span></code></dt>
<dd>
<section class="desc"><p>Built-in mutable sequence.</p>
<p>If no argument is given, the constructor creates a new empty list.
The argument must be an iterable if specified.</p></section>
</dd>
<dt id="app.board.Board.timerSpeed"><code class="name">var <span class="ident">timerSpeed</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="app.board.Board.drawBlackPiece"><code class="name flex">
<span>def <span class="ident">drawBlackPiece</span></span>(<span>self, painter, col, row)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper method to draw a black piece at the given col, row</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>painter</code></strong> :&ensp;<code>QPainter</code></dt>
<dd>The painter</dd>
</dl>
<p>col
(int):
The column to draw at
row
(int):
The row to draw at</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drawBlackPiece(self, painter, col, row):
    &#39;&#39;&#39;
        Helper method to draw a black piece at the given col, row

        Args:
            painter (QPainter): The painter
            col     (int):      The column to draw at
            row     (int):      The row to draw at
    &#39;&#39;&#39;
    self.drawPiece(painter, col, row, Qt.black)</code></pre>
</details>
</dd>
<dt id="app.board.Board.drawBoardSquares"><code class="name flex">
<span>def <span class="ident">drawBoardSquares</span></span>(<span>self, painter)</span>
</code></dt>
<dd>
<section class="desc"><p>Draw all the square on the board</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>painter</code></strong> :&ensp;<code>QPainter</code></dt>
<dd>The painter to paint on the widget with</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drawBoardSquares(self, painter):
    &#39;&#39;&#39;
        Draw all the square on the board

        Args:
            painter (QPainter): The painter to paint on the widget with
    &#39;&#39;&#39;
    for row in range(0, Board.boardHeight):
        for col in range(0, Board.boardWidth):
            self.drawSquare(
                painter, col, row, self.checkColours[0] if
                (col + row) % 2 == 1 else self.checkColours[1])</code></pre>
</details>
</dd>
<dt id="app.board.Board.drawEmptySpace"><code class="name flex">
<span>def <span class="ident">drawEmptySpace</span></span>(<span>self, painter, col, row)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper method to draw an empty space at the given col, row</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>painter</code></strong> :&ensp;<code>QPainter</code></dt>
<dd>The painter</dd>
</dl>
<p>col
(int):
The column to draw at
row
(int):
The row to draw at</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drawEmptySpace(self, painter, col, row):
    &#39;&#39;&#39;
        Helper method to draw an empty space at the given col, row

        Args:
            painter (QPainter): The painter
            col     (int):      The column to draw at
            row     (int):      The row to draw at
    &#39;&#39;&#39;
    self.drawPiece(painter, col, row, Qt.transparent)</code></pre>
</details>
</dd>
<dt id="app.board.Board.drawPiece"><code class="name flex">
<span>def <span class="ident">drawPiece</span></span>(<span>self, painter, col, row, color)</span>
</code></dt>
<dd>
<section class="desc"><p>Draw a piece at the given col, row
pen is doing the circle
brush is filling in the circle</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>painter</code></strong> :&ensp;<code>QPainter</code></dt>
<dd>The painter</dd>
</dl>
<p>col
(int):
The column to draw at
row
(int):
The row to draw at
color
(Qt.color): The color for the piece</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drawPiece(self, painter, col, row, color):
    &#39;&#39;&#39;
        Draw a piece at the given col, row
        pen is doing the circle
        brush is filling in the circle

        Args:
            painter (QPainter): The painter
            col     (int):      The column to draw at
            row     (int):      The row to draw at
            color   (Qt.color): The color for the piece
    &#39;&#39;&#39;
    painter.save()
    painter.setPen(QPen(QColor(color), 0))
    painter.setBrush(QColor(color))
    painter.translate(*self.getSquareCoords(col, row))
    radius = (self.squareWidth() - 2) / 5
    center = QPoint(self.squareWidth() // 2, self.squareHeight() // 2)
    painter.drawEllipse(center, radius, radius)
    painter.restore()</code></pre>
</details>
</dd>
<dt id="app.board.Board.drawPieces"><code class="name flex">
<span>def <span class="ident">drawPieces</span></span>(<span>self, painter)</span>
</code></dt>
<dd>
<section class="desc"><p>Draw the prices on the board</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>painter</code></strong> :&ensp;<code>QPainter</code></dt>
<dd>The painter to paint with</dd>
</dl>
<p>black and white squares being drawn on board</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drawPieces(self, painter):
    &#39;&#39;&#39;
        Draw the prices on the board

        Args:
            painter (QPainter): The painter to paint with

            black and white squares being drawn on board
    &#39;&#39;&#39;
    for row in range(0, len(self.boardArray)):
        for col in range(0, len(self.boardArray[0])):
            square = self.boardArray[row][col]
            if square == 0:
                self.drawEmptySpace(painter, col, row)
            elif square == 1:
                self.drawWhitePiece(painter, col, row)
            else:
                self.drawBlackPiece(painter, col, row)</code></pre>
</details>
</dd>
<dt id="app.board.Board.drawSquare"><code class="name flex">
<span>def <span class="ident">drawSquare</span></span>(<span>self, painter, col, row, color)</span>
</code></dt>
<dd>
<section class="desc"><p>Draw a board square on the board</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>painter</code></strong> :&ensp;<code>QPainter</code></dt>
<dd>The QPainter instance we are using</dd>
</dl>
<p>col
(int)
: The current column we are rendering in
row
(row)
: The current row we are rendering in
rgb
(iter)
: The rgba int values</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drawSquare(self, painter, col, row, color):
    &#39;&#39;&#39;
        Draw a board square on the board

        Args:
            painter (QPainter): The QPainter instance we are using
            col     (int)     : The current column we are rendering in
            row     (row)     : The current row we are rendering in
            rgb     (iter)    : The rgba int values
    &#39;&#39;&#39;
    width = int(self.squareWidth())
    height = int(self.squareHeight())
    midWidth = width // 2
    midHeight = height // 2
    painter.save()
    painter.translate(*self.getSquareCoords(col, row))
    painter.fillRect(0, 0, width, height, QColor(*color))
    painter.setPen(QPen(QColor(139, 69, 19), 2))
    painter.drawRect(0, 0, width, height)
    painter.drawLine(0, midHeight, width, midHeight)
    painter.drawLine(midWidth, 0, midWidth, height)
    painter.restore()</code></pre>
</details>
</dd>
<dt id="app.board.Board.drawWhitePiece"><code class="name flex">
<span>def <span class="ident">drawWhitePiece</span></span>(<span>self, painter, col, row)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper method to draw a white piece at the given col, row</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>painter</code></strong> :&ensp;<code>QPainter</code></dt>
<dd>The painter</dd>
</dl>
<p>col
(int):
The column to draw at
row
(int):
The row to draw at</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drawWhitePiece(self, painter, col, row):
    &#39;&#39;&#39;
        Helper method to draw a white piece at the given col, row

        Args:
            painter (QPainter): The painter
            col     (int):      The column to draw at
            row     (int):      The row to draw at
    &#39;&#39;&#39;
    self.drawPiece(painter, col, row, Qt.white)</code></pre>
</details>
</dd>
<dt id="app.board.Board.getCurrentPlayer"><code class="name flex">
<span>def <span class="ident">getCurrentPlayer</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper method to fetch the current player from the logic instance</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Player</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getCurrentPlayer(self):
    &#39;&#39;&#39;
        Helper method to fetch the current player from the logic instance

        Returns:
            Player
    &#39;&#39;&#39;
    return self.gameLogic.getPlayers()[self.gameLogic.player]</code></pre>
</details>
</dd>
<dt id="app.board.Board.getSquareCoords"><code class="name flex">
<span>def <span class="ident">getSquareCoords</span></span>(<span>self, col, row)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculate the square coords</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>col</code></strong> :&ensp;<code>int</code></dt>
<dd>The currrent col</dd>
<dt><strong><code>row</code></strong> :&ensp;<code>int</code></dt>
<dd>The current row</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getSquareCoords(self, col, row):
    &#39;&#39;&#39;
        Calculate the square coords

        Args:
            col (int): The currrent col
            row (int): The current row

        Returns:
            Tuple
    &#39;&#39;&#39;
    return (self.squareWidth() * col, self.squareHeight() * row)</code></pre>
</details>
</dd>
<dt id="app.board.Board.getSquareRowCol"><code class="name flex">
<span>def <span class="ident">getSquareRowCol</span></span>(<span>self, x, y)</span>
</code></dt>
<dd>
<section class="desc"><p>Given X and Y find the column and the row</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>int</code></dt>
<dd>The X POS</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>int</code></dt>
<dd>The Y POS</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getSquareRowCol(self, x, y):
    &#39;&#39;&#39;
        Given X and Y find the column and the row

        Args:
            x (int):    The X POS
            y (int):    The Y POS

        Returns:
            Tuple
    &#39;&#39;&#39;
    return (int(y // self.squareHeight()), int(x // self.squareWidth()))</code></pre>
</details>
</dd>
<dt id="app.board.Board.initBoard"><code class="name flex">
<span>def <span class="ident">initBoard</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Initiates the board</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initBoard(self):
    &#39;&#39;&#39;
        Initiates the board
    &#39;&#39;&#39;
    # Timer for tracking time
    self.timer = QBasicTimer()
    # Denotes if the game is underway
    self.isStarted = False
    # The initial board
    self.boardArray = [[Piece.NoPiece for j in range(self.boardWidth)]
                       for i in range(self.boardHeight)]
    # The gameLogic that controls play
    self.gameLogic = GameLogic(self.boardArray)
    # Start the game
    self.start()</code></pre>
</details>
</dd>
<dt id="app.board.Board.mousePressEvent"><code class="name flex">
<span>def <span class="ident">mousePressEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<section class="desc"><p>Mouse press event handler</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event</code></strong> :&ensp;<code>Event</code></dt>
<dd>The mouse press event</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mousePressEvent(self, event):
    &#39;&#39;&#39;
        Mouse press event handler

        Args:
            event (Event): The mouse press event
    &#39;&#39;&#39;
    # Get the current row/col where this click occured
    row, col = self.getSquareRowCol(event.x(), event.y())
    # On mouse press try and update the board logic
    try:
        self.gameLogic.updateBoard(row, col)
        self.updateLogicSignal.emit(&#34;&#34;)
    # Handle all of the different logical errors that can occur
    except KOError:
        self.updateLogicSignal.emit(f&#34;KO\ntry again&#34;)
    except SuicideError:
        self.updateLogicSignal.emit(f&#34;Suicide\ntry again&#34;)
    except OccupiedError:
        self.updateLogicSignal.emit(f&#34;Occupied\ntry again&#34;)
    # Whatever happens, update the board
    finally:
        self.boardArray = self.gameLogic.board
    # Emit the current player (this switches in the updateBoard logic)
    self.updateCurrentPlayerSignal.emit(self.getCurrentPlayer())
    # Emit the latest player objects
    self.updateScoreSignal.emit(self.gameLogic.getPlayers())
    # Redraw the GUI
    self.update()</code></pre>
</details>
</dd>
<dt id="app.board.Board.paintEvent"><code class="name flex">
<span>def <span class="ident">paintEvent</span></span>(<span>self, event=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Paints the board and the pieces of the game</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event</code></strong> :&ensp;<code>Event</code></dt>
<dd>The paint event</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def paintEvent(self, event=None):
    &#39;&#39;&#39;
        Paints the board and the pieces of the game

        Args:
            event (Event): The paint event
    &#39;&#39;&#39;
    painter = QPainter(self)
    self.drawBoardSquares(painter)
    self.drawPieces(painter)</code></pre>
</details>
</dd>
<dt id="app.board.Board.printBoardArray"><code class="name flex">
<span>def <span class="ident">printBoardArray</span></span>(<span>self, board)</span>
</code></dt>
<dd>
<section class="desc"><p>Pretty prints the boardArray to the terminal</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>board</code></strong> :&ensp;<code>list</code></dt>
<dd>A board</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def printBoardArray(self, board):
    &#39;&#39;&#39;
        Pretty prints the boardArray to the terminal

        Args:
            board (list): A board
    &#39;&#39;&#39;
    print(&#34;boardArray:&#34;)
    print(&#39;\n&#39;.join(
        [&#39;\t&#39;.join([str(cell) for cell in row]) for row in board]))</code></pre>
</details>
</dd>
<dt id="app.board.Board.resetGame"><code class="name flex">
<span>def <span class="ident">resetGame</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Clears pieces from the board'</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resetGame(self):
    &#39;&#39;&#39;
        Clears pieces from the board&#39;
    &#39;&#39;&#39;
    # Reset the logic
    self.gameLogic.reset()
    # Reset the board
    self.boardArray = self.gameLogic.board
    # Emit the player objects with reset scores
    self.updateScoreSignal.emit(self.gameLogic.getPlayers())
    # Emit the current player
    self.updateCurrentPlayerSignal.emit(self.getCurrentPlayer())
    # Redraw the GUI
    self.update()</code></pre>
</details>
</dd>
<dt id="app.board.Board.skip"><code class="name flex">
<span>def <span class="ident">skip</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Handle skip / passes</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def skip(self):
    &#39;&#39;&#39;
        Handle skip / passes
    &#39;&#39;&#39;
    # Try and skip a go, unless there are two skips - then emit game over
    try:
        self.gameLogic.skip()
        self.updateCurrentPlayerSignal.emit(self.getCurrentPlayer())
    except GameOverPassError:
        self.updateGameOverSignal.emit()</code></pre>
</details>
</dd>
<dt id="app.board.Board.squareHeight"><code class="name flex">
<span>def <span class="ident">squareHeight</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the height of one square of the board</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def squareHeight(self):
    &#39;&#39;&#39;
        Returns the height of one square of the board

        Returns:
            float
    &#39;&#39;&#39;
    return self.contentsRect().height() / self.boardHeight</code></pre>
</details>
</dd>
<dt id="app.board.Board.squareWidth"><code class="name flex">
<span>def <span class="ident">squareWidth</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the width of one square in the board</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def squareWidth(self):
    &#39;&#39;&#39;
        Returns the width of one square in the board

        Returns:
            float
    &#39;&#39;&#39;
    return self.contentsRect().width() / self.boardWidth</code></pre>
</details>
</dd>
<dt id="app.board.Board.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Start the game</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self):
    &#39;&#39;&#39;
        Start the game
    &#39;&#39;&#39;
    self.isStarted = True  # determines if the game has started to TRUE
    self.resetGame()  # reset the game
    self.timer.start(self.timerSpeed, self)</code></pre>
</details>
</dd>
<dt id="app.board.Board.timerEvent"><code class="name flex">
<span>def <span class="ident">timerEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<section class="desc"><p>This event is automatically called when the timer is updated.
Based on the timerSpeed variable.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event</code></strong> :&ensp;<code>Event</code></dt>
<dd>Timer event</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def timerEvent(self, event):
    &#39;&#39;&#39;
        This event is automatically called when the timer is updated.
        Based on the timerSpeed variable.

        Args:
            event (Event): Timer event
    &#39;&#39;&#39;
    # if the timer that has &#39;ticked&#39; is the one in this class
    if event.timerId() == self.timer.timerId():
        # Get the current player
        player = self.getCurrentPlayer()
        # If there is no time remaining, then game over
        if player.timeRemaining &lt;= 0:
            self.updateGameOverSignal.emit()
        else:
            player.timeRemaining -= 1
        # Emit the new state of the timer
        self.updatePlayersTimer.emit(self.gameLogic.getPlayers())
    else:
        # if we do not handle an event pass it to the parent class
        super(Board, self).timerEvent(event)</code></pre>
</details>
</dd>
<dt id="app.board.Board.undo"><code class="name flex">
<span>def <span class="ident">undo</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Undo last turn</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def undo(self):
    &#39;&#39;&#39;
        Undo last turn
    &#39;&#39;&#39;
    print(&#34;Not implemented&#34;)</code></pre>
</details>
</dd>
<dt id="app.board.Board.updateCurrentPlayerSignal"><code class="name flex">
<span>def <span class="ident">updateCurrentPlayerSignal</span></span>(<span>...)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="app.board.Board.updateGameOverSignal"><code class="name flex">
<span>def <span class="ident">updateGameOverSignal</span></span>(<span>...)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="app.board.Board.updateLogicSignal"><code class="name flex">
<span>def <span class="ident">updateLogicSignal</span></span>(<span>...)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="app.board.Board.updatePlayersTimer"><code class="name flex">
<span>def <span class="ident">updatePlayersTimer</span></span>(<span>...)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="app.board.Board.updateScoreSignal"><code class="name flex">
<span>def <span class="ident">updateScoreSignal</span></span>(<span>...)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="app" href="index.html">app</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="app.board.Board" href="#app.board.Board">Board</a></code></h4>
<ul class="">
<li><code><a title="app.board.Board.boardHeight" href="#app.board.Board.boardHeight">boardHeight</a></code></li>
<li><code><a title="app.board.Board.boardWidth" href="#app.board.Board.boardWidth">boardWidth</a></code></li>
<li><code><a title="app.board.Board.checkColours" href="#app.board.Board.checkColours">checkColours</a></code></li>
<li><code><a title="app.board.Board.drawBlackPiece" href="#app.board.Board.drawBlackPiece">drawBlackPiece</a></code></li>
<li><code><a title="app.board.Board.drawBoardSquares" href="#app.board.Board.drawBoardSquares">drawBoardSquares</a></code></li>
<li><code><a title="app.board.Board.drawEmptySpace" href="#app.board.Board.drawEmptySpace">drawEmptySpace</a></code></li>
<li><code><a title="app.board.Board.drawPiece" href="#app.board.Board.drawPiece">drawPiece</a></code></li>
<li><code><a title="app.board.Board.drawPieces" href="#app.board.Board.drawPieces">drawPieces</a></code></li>
<li><code><a title="app.board.Board.drawSquare" href="#app.board.Board.drawSquare">drawSquare</a></code></li>
<li><code><a title="app.board.Board.drawWhitePiece" href="#app.board.Board.drawWhitePiece">drawWhitePiece</a></code></li>
<li><code><a title="app.board.Board.getCurrentPlayer" href="#app.board.Board.getCurrentPlayer">getCurrentPlayer</a></code></li>
<li><code><a title="app.board.Board.getSquareCoords" href="#app.board.Board.getSquareCoords">getSquareCoords</a></code></li>
<li><code><a title="app.board.Board.getSquareRowCol" href="#app.board.Board.getSquareRowCol">getSquareRowCol</a></code></li>
<li><code><a title="app.board.Board.initBoard" href="#app.board.Board.initBoard">initBoard</a></code></li>
<li><code><a title="app.board.Board.mousePressEvent" href="#app.board.Board.mousePressEvent">mousePressEvent</a></code></li>
<li><code><a title="app.board.Board.paintEvent" href="#app.board.Board.paintEvent">paintEvent</a></code></li>
<li><code><a title="app.board.Board.printBoardArray" href="#app.board.Board.printBoardArray">printBoardArray</a></code></li>
<li><code><a title="app.board.Board.resetGame" href="#app.board.Board.resetGame">resetGame</a></code></li>
<li><code><a title="app.board.Board.skip" href="#app.board.Board.skip">skip</a></code></li>
<li><code><a title="app.board.Board.squareHeight" href="#app.board.Board.squareHeight">squareHeight</a></code></li>
<li><code><a title="app.board.Board.squareWidth" href="#app.board.Board.squareWidth">squareWidth</a></code></li>
<li><code><a title="app.board.Board.start" href="#app.board.Board.start">start</a></code></li>
<li><code><a title="app.board.Board.timerEvent" href="#app.board.Board.timerEvent">timerEvent</a></code></li>
<li><code><a title="app.board.Board.timerSpeed" href="#app.board.Board.timerSpeed">timerSpeed</a></code></li>
<li><code><a title="app.board.Board.undo" href="#app.board.Board.undo">undo</a></code></li>
<li><code><a title="app.board.Board.updateCurrentPlayerSignal" href="#app.board.Board.updateCurrentPlayerSignal">updateCurrentPlayerSignal</a></code></li>
<li><code><a title="app.board.Board.updateGameOverSignal" href="#app.board.Board.updateGameOverSignal">updateGameOverSignal</a></code></li>
<li><code><a title="app.board.Board.updateLogicSignal" href="#app.board.Board.updateLogicSignal">updateLogicSignal</a></code></li>
<li><code><a title="app.board.Board.updatePlayersTimer" href="#app.board.Board.updatePlayersTimer">updatePlayersTimer</a></code></li>
<li><code><a title="app.board.Board.updateScoreSignal" href="#app.board.Board.updateScoreSignal">updateScoreSignal</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>